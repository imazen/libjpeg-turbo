/*
 * jocldsample.h
 *
 * Copyright (C) 2012-2013, MulticoreWare Inc.
 * In July 2013, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
 * The OpenCL kernel code is written by
 *   Chunli  Zhang <chunli@multicorewareinc.com> and
 *   Peixuan Zhang <peixuan@multicorewareinc.com>
 * Based on the OpenCL extension for IJG JPEG library,
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the kernels of OpenCL decoding.
 */

#if defined(OPENCL_DEC_UPSAMPLE_RGB)
static const char     * jocldec_cl_source2  =
"__kernel void UPSAMPLE_H1V1_RGB        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
static const char     * jocldec_cl_source3  =
"__kernel void UPSAMPLE_H1V1_BGR        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
static const char     * jocldec_cl_source4  =
"__kernel void UPSAMPLE_H1V1_RGBA       (__global uchar  *src,            \n"
#endif
"                                        __global uchar4 *dst,            \n"
"                                        __local  uchar  *inter,          \n"
"                                        const    uint    mcu_width,      \n"
"                                        const    uint    mcu_offset)     \n"
"{                                                                        \n"
"  uint    globalIdx = get_global_id(0);                                  \n"
"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
"  uint    localIdx  = get_local_id (0);                                  \n"
"  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
"  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
"  uchar   dataInCr  = src[globalIdx / 64 * 192 + 128 + localIdx];        \n"
"  uchar   imgR, imgG, imgB;                                              \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  uchar   imgA = 255;;                                                   \n"
#endif
"  uint    x, y;                                                          \n"
"                                                                         \n"
"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
"                                                                         \n"
"  imgB = convert_uchar_sat(                                              \n"
"    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
"  imgG = convert_uchar_sat(                                              \n"
"    dataInY + ((((int)32768 - (int)22554 * (dataInCb - 128))             \n"
"    - ((int)46802 * (dataInCr - 128))) >> 16));                          \n"
"  imgR = convert_uchar_sat(                                              \n"
"    dataInY  + ((116130 * (dataInCb - 128) + 32768) >> 16));             \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"  inter[localIdx * 3 + 0] = imgR;                                        \n"
"  inter[localIdx * 3 + 1] = imgG;                                        \n"
"  inter[localIdx * 3 + 2] = imgB;                                        \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"  inter[localIdx * 3 + 0] = imgB;                                        \n"
"  inter[localIdx * 3 + 1] = imgG;                                        \n"
"  inter[localIdx * 3 + 2] = imgR;                                        \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  inter[localIdx * 4 + 0] = imgR;                                        \n"
"  inter[localIdx * 4 + 1] = imgG;                                        \n"
"  inter[localIdx * 4 + 2] = imgB;                                        \n"
"  inter[localIdx * 4 + 3] = imgA;                                        \n"
#endif
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  if (localIdx < 64)                                                     \n"
"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8                        \n"
"      + localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);         \n"
#else
"  if (localIdx < 48)                                                     \n"
"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6                        \n"
"      + localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);         \n"
#endif
"}                                                                        \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"__kernel void UPSAMPLE_H1V2_RGB        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"__kernel void UPSAMPLE_H1V2_BGR        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"__kernel void UPSAMPLE_H1V2_RGBA       (__global uchar  *src,            \n"
#endif
"                                        __global uchar4 *dst,            \n"
"                                        __local  uchar  *inter,          \n"
"                                        __local  uchar  *cb_cache,       \n"
"                                        __local  uchar  *cr_cache,       \n"
"                                        const    uint    mcu_width,      \n"
"                                        const    uint    mcu_offset)     \n"
"{                                                                        \n"
"  uint    globalIdx = get_global_id(0);                                  \n"
"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
"  uint    localIdx  =  get_local_id(0);                                  \n"
"  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
"  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
"  uchar   imgR, imgG, imgB;                                              \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  uchar   imgA = 255;;                                                   \n"
#endif
"  uint    x, y;                                                          \n"
"                                                                         \n"
"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
"                                                                         \n"
"  if (localIdx < 64)                                                     \n"
"  {                                                                      \n"
"    cb_cache[localIdx] = src[globalIdx / 128 * 256 + 128 + localIdx];    \n"
"    cr_cache[localIdx] = src[globalIdx / 128 * 256 + 192 + localIdx];    \n"
"  }                                                                      \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  imgB = convert_uchar_sat(dataInY  +                                    \n"
"    (((int)91881 * (cr_cache[transOffset] - 128) + (int)32768) >> 16));  \n"
"  imgG = convert_uchar_sat(dataInY +                                     \n"
"    ((((int)32768 - (int)22554 * (cb_cache[transOffset] - 128))          \n"
"    - ((int)46802 * (cr_cache[transOffset] - 128))) >> 16));             \n"
"  imgR = convert_uchar_sat(dataInY  +                                    \n"
"    (((int)116130 * (cb_cache[transOffset] - 128) + (int)32768) >> 16)); \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"  inter[localIdx * 3 + 0] = imgR;                                        \n"
"  inter[localIdx * 3 + 1] = imgG;                                        \n"
"  inter[localIdx * 3 + 2] = imgB;                                        \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"  inter[localIdx * 3 + 0] = imgB;                                        \n"
"  inter[localIdx * 3 + 1] = imgG;                                        \n"
"  inter[localIdx * 3 + 2] = imgR;                                        \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  inter[localIdx * 4+ 0] = imgR;                                         \n"
"  inter[localIdx * 4+ 1] = imgG;                                         \n"
"  inter[localIdx * 4+ 2] = imgB;                                         \n"
"  inter[localIdx * 4+ 3] = imgA;                                         \n"
#endif
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  if (localIdx < 128)                                                    \n"
"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8 +                     \n"
"      localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);           \n"
#else
"  if (localIdx < 96)                                                     \n"
"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6 +                      \n"
"      localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);           \n"
#endif
"}                                                                        \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"__kernel void UPSAMPLE_H2V1_RGB        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"__kernel void UPSAMPLE_H2V1_BGR        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"__kernel void UPSAMPLE_H2V1_RGBA       (__global uchar  *src,            \n"
#endif
"                                        __global uchar8 *dst,            \n"
"                                        __local  uchar  *inter,          \n"
"                                        __local  uchar  *cb_cache,       \n"
"                                        __local  uchar  *cr_cache,       \n"
"                                        __local  uchar2 *cb_upsample,    \n"
"                                        __local  uchar2 *cr_upsample,    \n"
"                                        const    uint    mcu_width,      \n"
"                                        const    uint    mcu_offset)     \n"
"{                                                                        \n"
"  uint    globalIdx   = get_global_id(0);                                \n"
"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
"  uint    localIdx    = get_local_id (0);                                \n"
"  uint    transOffset =                                                  \n"
"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
"  uchar2  imgR, imgG, imgB;                                              \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  uchar2  imgA  = 255;                                                   \n"
#endif
"  int     valueY,valueCb, valueCr;                                       \n"
"  uint    x, y;                                                          \n"
"                                                                         \n"
"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
"                                                                         \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  cb_upsample[localIdx].x = dataInCb;                                    \n"
"  cb_upsample[localIdx].y = dataInCb;                                    \n"
"  cr_upsample[localIdx].x = dataInCr;                                    \n"
"  cr_upsample[localIdx].y = dataInCr;                                    \n"
"                                                                         \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  valueY = convert_int(dataInY.x);                                       \n"
"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
"                                                                         \n"
"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
"  valueY  = convert_int(dataInY.y);                                      \n"
"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
"                                                                         \n"
"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
#endif
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  if (localIdx < 64)                                                     \n"
"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
"      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
#else
"  if (localIdx < 48)                                                     \n"
"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
#endif
"}                                                                        \n"
"                                                                         \n"
"__kernel __attribute__((reqd_work_group_size(128,1,1)))                  \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"         void UPSAMPLE_H2V2_RGB        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"         void UPSAMPLE_H2V2_BGR        (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"         void UPSAMPLE_H2V2_RGBA       (__global uchar  *src,            \n"
#endif
"                                        __global uchar8 *dst,            \n"
"                                        __local  uchar  *inter,          \n"
"                                        __local  uchar  *cb_cache,       \n"
"                                        __local  uchar  *cr_cache,       \n"
"                                        __local  uchar2 *cb_upsample,    \n"
"                                        __local  uchar2 *cr_upsample,    \n"
"                                        const    uint    mcu_width,      \n"
"                                        const    uint    mcu_offset)     \n"
"{                                                                        \n"
"  uint    globalIdx   = get_global_id(0);                                \n"
"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
"  uint    localIdx    = get_local_id (0);                                \n"
"  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
"  uchar2  dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);     \n"
"  uchar2  imgR, imgG, imgB;                                              \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  uchar2  imgA = 255;                                                    \n"
#endif
"  int     valueY, valueCb, valueCr;                                      \n"
"  uint    x, y;                                                          \n"
"                                                                         \n"
"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
"                                                                         \n"
"  if (localIdx < 64)                                                     \n"
"  {                                                                      \n"
"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
"      cb_cache[localIdx];                                                \n"
"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
"      cb_cache[localIdx];                                                \n"
"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
"      cr_cache[localIdx];                                                \n"
"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
"      cr_cache[localIdx];                                                \n"
"  }                                                                      \n"
"                                                                         \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  valueY  = convert_int(dataInY.x);                                      \n"
"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
"                                                                         \n"
"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
"  valueY  = convert_int(dataInY.y);                                      \n"
"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
"                                                                         \n"
"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
#endif
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  if (localIdx < 128)                                                    \n"
"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
#else
"  if (localIdx < 96)                                                     \n"
"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
#endif
"}                                                                        \n";
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
static const char     * jocldec_cl_source5  =
"#define MCUNUMS  800                                                     \n"
"__kernel void UPSAMPLE_H2V1_FANCY_RGB  (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
static const char     * jocldec_cl_source6  =
"#define MCUNUMS  800                                                     \n"
"__kernel void UPSAMPLE_H2V1_FANCY_BGR  (__global uchar  *src,            \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
static const char     * jocldec_cl_source7  =
"#define MCUNUMS  800                                                     \n"
"__kernel void UPSAMPLE_H2V1_FANCY_RGBA (__global uchar  *src,            \n"
#endif
"                                        __global uchar8 *dst,            \n"
"                                        __global uchar  *dst_inter,      \n"
"                                        __local  uchar  *inter,          \n"
"                                        __local  uchar  *cb_cache,       \n"
"                                        __local  uchar  *cr_cache,       \n"
"                                        __local  uchar2 *cb_upsample,    \n"
"                                        __local  uchar2 *cr_upsample,    \n"
"                                        const    uint    mcu_width,      \n"
"                                        const    uint    mcu_offset,     \n"
"                                        const    uint    edge_mcu)       \n"
"{                                                                        \n"
"  uint    globalIdx   = get_global_id(0);                                \n"
"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
"  uint    localIdx    = get_local_id (0);                                \n"
"  uint    transOffset =                                                  \n"
"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
"  uchar   dataInCbLeft, dataInCrLeft, dataInCbRight, dataInCrRight;      \n"
"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
"  uchar2  imgR, imgG, imgB;                                              \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  uchar2  imgA = 255;                                                    \n"
#endif
"  int     valueY,valueCb, valueCr;                                       \n"
"  uint    x, y;                                                          \n"
"                                                                         \n"
"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
"                                                                         \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  if (!(localIdx & 0x07) && !(globalIdx1 / 64 % mcu_width)) {            \n"
"    dataInCbLeft  = dataInCb -1;                                         \n"
"    dataInCrLeft  = dataInCr -1;                                         \n"
"  }                                                                      \n"
"  else if (!(localIdx & 0x07) && (globalIdx1 / 64 % mcu_width)           \n"
"    && (globalIdx / 64)) {                                               \n"
"    dataInCbLeft  = src[globalIdx / 64 * 256 - 121 + localIdx];          \n"
"    dataInCrLeft  = src[globalIdx / 64 * 256 + localIdx - 57];           \n"
"  }                                                                      \n"
"  else if (!(localIdx & 0x07) && (globalIdx1 / 64 % mcu_width)           \n"
"    && !(globalIdx / 64)) {                                              \n"
"    dataInCbLeft  = dst_inter[localIdx / 8];                             \n"
"    dataInCrLeft  = dst_inter[localIdx / 8 + 8];                         \n"
"  }                                                                      \n"
"  else {                                                                 \n"
"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
"  }                                                                      \n"
"  if ((localIdx & 0x07) == edge_mcu &&                                   \n"
"           (globalIdx1 / 64 % mcu_width) == (mcu_width - 1)) {           \n"
"    dataInCbRight = dataInCb -2;                                         \n"
"    dataInCrRight = dataInCr -2;                                         \n"
"  }                                                                      \n"
"  else if ((localIdx & 0x07) == 7 &&                                     \n"
"           (globalIdx1 / 64 % mcu_width) != (mcu_width - 1)) {           \n"
"    dataInCbRight = src[globalIdx / 64 * 256 + localIdx + 57 + 320];     \n"
"    dataInCrRight = src[globalIdx / 64 * 256 + localIdx + 57 + 384];     \n"
"  }                                                                      \n"
"  else {                                                                 \n"
"    dataInCbRight = cb_cache[localIdx+1];                                \n"
"    dataInCrRight = cr_cache[localIdx+1];                                \n"
"  }                                                                      \n"
"                                                                         \n"
"  cb_upsample[localIdx].x = (dataInCb * 3 + dataInCbLeft  + 1) >> 2;     \n"
"  cb_upsample[localIdx].y = (dataInCb * 3 + dataInCbRight + 2) >> 2;     \n"
"  cr_upsample[localIdx].x = (dataInCr * 3 + dataInCrLeft  + 1) >> 2;     \n"
"  cr_upsample[localIdx].y = (dataInCr * 3 + dataInCrRight + 2) >> 2;     \n"
"                                                                         \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  valueY = convert_int(dataInY.x);                                       \n"
"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
"                                                                         \n"
"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
"  valueY  = convert_int(dataInY.y);                                      \n"
"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
"                                                                         \n"
"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
#endif
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"  if(globalIdx == 0) {                                                   \n"
"    dst_inter[0] = src[(MCUNUMS - 2) * 256 + 128 + 7];                   \n"
"    dst_inter[1] = src[(MCUNUMS - 2) * 256 + 128 + 15];                  \n"
"    dst_inter[2] = src[(MCUNUMS - 2) * 256 + 128 + 23];                  \n"
"    dst_inter[3] = src[(MCUNUMS - 2) * 256 + 128 + 31];                  \n"
"    dst_inter[4] = src[(MCUNUMS - 2) * 256 + 128 + 39];                  \n"
"    dst_inter[5] = src[(MCUNUMS - 2) * 256 + 128 + 47];                  \n"
"    dst_inter[6] = src[(MCUNUMS - 2) * 256 + 128 + 55];                  \n"
"    dst_inter[7] = src[(MCUNUMS - 2) * 256 + 128 + 63];                  \n"
"    dst_inter[8] = src[(MCUNUMS - 2) * 256 + 192 + 7];                   \n"
"    dst_inter[9] = src[(MCUNUMS - 2) * 256 + 192 + 15];                  \n"
"    dst_inter[10] = src[(MCUNUMS - 2) * 256 + 192 + 23];                 \n"
"    dst_inter[11] = src[(MCUNUMS - 2) * 256 + 192 + 31];                 \n"
"    dst_inter[12] = src[(MCUNUMS - 2) * 256 + 192 + 39];                 \n"
"    dst_inter[13] = src[(MCUNUMS - 2) * 256 + 192 + 47];                 \n"
"    dst_inter[14] = src[(MCUNUMS - 2) * 256 + 192 + 55];                 \n"
"    dst_inter[15] = src[(MCUNUMS - 2) * 256 + 192 + 63];                 \n"
"  }                                                                      \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  if (localIdx < 64)                                                     \n"
"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
"      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
#else
"  if (localIdx < 48)                                                     \n"
"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
#endif
"}                                                                        \n"
"__kernel __attribute__((reqd_work_group_size(128,1,1)))                  \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"        void UPSAMPLE_H2V2_FANCY_RGB (__global uchar  *src,              \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"        void UPSAMPLE_H2V2_FANCY_BGR (__global uchar  *src,              \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"__kernel void UPSAMPLE_H2V2_FANCY_RGBA (__global uchar  *src,            \n"
#endif
"                                      __global uchar  *src1,             \n"
"                                      __global uchar8 *dst,              \n"
"                                      __global uchar  *src_prior,        \n"
"                                      __global uchar  *dst_prior,        \n"
"                                      __local  uchar  *inter,            \n"
"                                      __local  uchar  *cb_cache,         \n"
"                                      __local  uchar  *cr_cache,         \n"
"                                      __local  uchar2 *cb_upsample,      \n"
"                                      __local  uchar2 *cr_upsample,      \n"
"                                      const    uint    mcu_width,        \n"
"                                      const    uint    mcu_offset,       \n"
"                                      const    uint    mcu_total,        \n"
"                                      const    uint    edge_mcu_h,       \n"
"                                      const    uint    edge_mcu_v,       \n"
"                                      const    uint    mcu_offset_buffer)\n"
"{                                                                        \n"
"  uint   globalIdx   = get_global_id(0);                                 \n"
"  uint   globalIdx1  = get_global_id(0) + mcu_offset;                    \n"
"  uint   globalMCUIdx= globalIdx1/128;                                   \n"
"  uint   localIdx    = get_local_id (0);                                 \n"
"  uint   localIdx1   = get_local_id (0) - 64;                            \n"
"  uint   groupIdx    = get_group_id (0);                                 \n"
"  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
"  uchar2 dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);      \n"
"  uchar2 imgR, imgG, imgB;                                               \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  uchar2 imgA = 255;                                                     \n"
#endif
"  int    valueY, valueCb, valueCr;                                       \n"
"  uint   x, y;                                                           \n"
"  int    dataInTopCb, dataInBottomCb, dataInRightCb, dataInLeftCb;       \n"
"  int    dataInLeftTopCb, dataInRightTopCb;                              \n"
"  int    dataInLeftBottomCb, dataInRightBottomCb;                        \n"
"  int    dataInTopCr, dataInBottomCr, dataInRightCr, dataInLeftCr;       \n"
"  int    dataInLeftTopCr, dataInRightTopCr;                              \n"
"  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
"  uint   trans8to10 = (localIdx / 8) * 10 + (localIdx % 8) + 11;         \n"
"  uint   trans8to10_1 = ((localIdx - 64) / 8) * 10 + (localIdx % 8) + 11;\n"
"  uint   upsample_offset = localIdx + localIdx%8/4*28+localIdx/32*32;    \n"
"  uint   upsample_offset1 = localIdx1 + localIdx1%8/4*28+localIdx1/32*32;\n"
"  uint   group_ptr_offset = groupIdx * 384;                              \n"
"  uchar  dataInCb ,dataInCr;                                             \n"
"                                                                         \n"
"  x = globalMCUIdx % mcu_width;                                          \n"
"  y = globalMCUIdx / mcu_width;                                          \n"
"  if (localIdx < 64)                                                     \n"
"  {                                                                      \n"
"    cb_cache[trans8to10] = src[group_ptr_offset + 256 + localIdx];       \n"
"    cr_cache[trans8to10] = src[group_ptr_offset + 320 + localIdx];       \n"
"  }                                                                      \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"  if (localIdx < 8)                                                      \n"
"  {                                                                      \n"
"    if (!(globalMCUIdx / mcu_width))                                     \n"
"    {                                                                    \n"
"      cb_cache[localIdx + 1] = cb_cache[localIdx + 11];                  \n"
"      cr_cache[localIdx + 1] = cr_cache[localIdx + 11];                  \n"
"    }                                                                    \n"
"    else if (globalIdx / 128 < mcu_width)                                \n"
"    {                                                                    \n"
"      cb_cache[localIdx + 1] = src_prior[groupIdx * 16 + localIdx];      \n"
"      cr_cache[localIdx + 1] = src_prior[groupIdx * 16 + 8 + localIdx];  \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[localIdx + 1] = src[(globalIdx/128 - mcu_width) * 384     \n"
"        + 256 + 56 + localIdx];                                          \n"
"      cr_cache[localIdx + 1] = src[(globalIdx/128 - mcu_width) * 384     \n"
"        + 320 + 56 + localIdx];                                          \n"
"    }                                                                    \n"
"    if ((globalMCUIdx / mcu_width) == (mcu_total /128 /mcu_width - 1))   \n"
"    {                                                                    \n"
"      cb_cache[localIdx + 11 + edge_mcu_v * 10]                          \n"
"                      = cb_cache[localIdx + 1 + edge_mcu_v * 10];        \n"
"      cr_cache[localIdx + 11 + edge_mcu_v * 10]                          \n"
"                      = cr_cache[localIdx + 1 + edge_mcu_v * 10];        \n"
"    }                                                                    \n"
"    else if (globalIdx >= mcu_offset_buffer)                             \n"
"    {                                                                    \n"
"      cb_cache[localIdx + 91] = src1[globalIdx / 128 % mcu_width * 384   \n"
"        + 256 + localIdx];                                               \n"
"      cr_cache[localIdx + 91] = src1[globalIdx / 128 % mcu_width * 384   \n"
"        + 320 + localIdx];                                               \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[localIdx + 91] = src[(globalIdx/128 + mcu_width) * 384    \n"
"        + 256 + localIdx];                                               \n"
"      cr_cache[localIdx + 91] = src[(globalIdx/128 + mcu_width) * 384    \n"
"        + 320 + localIdx];                                               \n"
"    }                                                                    \n"
"    if (!(globalMCUIdx % mcu_width))                                     \n"
"    {                                                                    \n"
"      cb_cache[localIdx * 10 + 10] = cb_cache[localIdx * 10 + 11];       \n"
"      cr_cache[localIdx * 10 + 10] = cr_cache[localIdx * 10 + 11];       \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[localIdx * 10 + 10] = src[group_ptr_offset - 121 +        \n"
"        localIdx * 8];                                                   \n"
"      cr_cache[localIdx * 10 + 10] = src[group_ptr_offset - 57 +         \n"
"        localIdx * 8];                                                   \n"
"    }                                                                    \n"
"    if ((globalMCUIdx % mcu_width) == (mcu_width - 1))                   \n"
"    {                                                                    \n"
"      cb_cache[localIdx * 10 + 12 + edge_mcu_h]                          \n"
"                       = cb_cache[localIdx * 10 + 11 + edge_mcu_h];      \n"
"      cr_cache[localIdx * 10 + 12 + edge_mcu_h]                          \n"
"                       = cr_cache[localIdx * 10 + 11 + edge_mcu_h];      \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[localIdx * 10 + 19] = src[group_ptr_offset + 640          \n"
"        + localIdx * 8];                                                 \n"
"      cr_cache[localIdx * 10 + 19] = src[group_ptr_offset + 704          \n"
"        + localIdx * 8];                                                 \n"
"    }                                                                    \n"
"  }                                                                      \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"  if (localIdx == 0)                                                     \n"
"  {                                                                      \n"
"    if (!(globalIdx / 128 % mcu_width))                                  \n"
"    {                                                                    \n"
"      cb_cache[0] = cb_cache[1];                                         \n"
"      cr_cache[0] = cr_cache[1];                                         \n"
"    }                                                                    \n"
"    else if(!(globalMCUIdx / mcu_width))                                 \n"
"    {                                                                    \n"
"      cb_cache[0] = src[group_ptr_offset - 121];                         \n"
"      cr_cache[0] = src[group_ptr_offset - 57];                          \n"
"    }                                                                    \n"
"    else if (globalIdx / 128 < mcu_width)                                \n"
"    {                                                                    \n"
"      cb_cache[0] = src_prior[groupIdx * 16 - 9];                        \n"
"      cr_cache[0] = src_prior[groupIdx * 16 - 1];                        \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[0] = src[(globalIdx/128 - mcu_width - 1)* 384 + 256 + 63];\n"
"      cr_cache[0] = src[(globalIdx/128 - mcu_width - 1)* 384 + 320 + 63];\n"
"    }                                                                    \n"
"    if(!(globalIdx / 128 % mcu_width))                                   \n"
"    {                                                                    \n"
"      cb_cache[90] = cb_cache[91];                                       \n"
"      cr_cache[90] = cr_cache[91];                                       \n"
"    }                                                                    \n"
"    else if((globalMCUIdx/ mcu_width) == (mcu_total /128 /mcu_width - 1))\n"
"    {                                                                    \n"
"      cb_cache[10 + edge_mcu_v * 10] = src[group_ptr_offset - 384 + 256  \n"
"        + edge_mcu_v * 8 - 1];                                           \n"
"      cr_cache[10 + edge_mcu_v * 10] = src[group_ptr_offset - 384 + 320  \n"
"        + edge_mcu_v * 8 - 1];                                           \n"
"    }                                                                    \n"
"    else if(globalIdx >= mcu_offset_buffer)                              \n"
"    {                                                                    \n"
"      cb_cache[90] = src1[globalIdx / 128 % mcu_width * 384 - 121];      \n"
"      cr_cache[90] = src1[globalIdx / 128 % mcu_width * 384 - 57];       \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[90] = src[(globalIdx/128 + mcu_width - 1)* 384 + 256 + 7];\n"
"      cr_cache[90] = src[(globalIdx/128 + mcu_width - 1)* 384 + 320 + 7];\n"
"    }                                                                    \n"
"    if ((globalMCUIdx % mcu_width) == (mcu_width - 1))                   \n"
"    {                                                                    \n"
"      cb_cache[edge_mcu_h + 2] = cb_cache[edge_mcu_h + 1];               \n"
"      cr_cache[edge_mcu_h + 2] = cr_cache[edge_mcu_h + 1];               \n"
"    }                                                                    \n"
"    else if (!(globalMCUIdx / mcu_width))                                \n"
"    {                                                                    \n"
"      cb_cache[9] = src[group_ptr_offset + 640];                         \n"
"      cr_cache[9] = src[group_ptr_offset + 704];                         \n"
"    }                                                                    \n"
"    else if (globalIdx / 128 < mcu_width)                                \n"
"    {                                                                    \n"
"      cb_cache[9] = src_prior[groupIdx * 16 + 16];                       \n"
"      cr_cache[9] = src_prior[groupIdx * 16 + 24];                       \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[9] = src[(globalIdx/128 - mcu_width + 1)* 384 + 256 + 56];\n"
"      cr_cache[9] = src[(globalIdx/128 - mcu_width + 1)* 384 + 320 + 56];\n"
"    }                                                                    \n"
"    if ((globalMCUIdx % mcu_width) == (mcu_width - 1))                   \n"
"    {                                                                    \n"
"      cb_cache[edge_mcu_h + 92]  = cb_cache[edge_mcu_h + 91];            \n"
"      cr_cache[edge_mcu_h + 92]  = cr_cache[edge_mcu_h + 91];            \n"
"    }                                                                    \n"
"    else if((globalMCUIdx/ mcu_width) == (mcu_total /128 /mcu_width - 1))\n"
"    {                                                                    \n"
"      cb_cache[19 + edge_mcu_v * 10] = src[group_ptr_offset + 384 + 256  \n"
"        + edge_mcu_v * 8 - 8];                                           \n"
"      cr_cache[19 + edge_mcu_v * 10] = src[group_ptr_offset + 384 + 320  \n"
"        + edge_mcu_v * 8 - 8];                                           \n"
"    }                                                                    \n"
"    else if(globalIdx >= mcu_offset_buffer)                              \n"
"    {                                                                    \n"
"      cb_cache[99]  = src1[globalIdx / 128 % mcu_width * 384 + 640];     \n"
"      cr_cache[99]  = src1[globalIdx / 128 % mcu_width * 384 + 704];     \n"
"    }                                                                    \n"
"    else                                                                 \n"
"    {                                                                    \n"
"      cb_cache[99]  = src[(globalIdx/128 + mcu_width + 1) * 384 + 256];  \n"
"      cr_cache[99]  = src[(globalIdx/128 + mcu_width + 1) * 384 + 320];  \n"
"    }                                                                    \n"
"  }                                                                      \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"  if(localIdx < 8 && globalIdx >= mcu_offset_buffer) {                   \n"
"    dst_prior[groupIdx % mcu_width * 16 + localIdx]                      \n"
"      = cb_cache[localIdx + 81];                                         \n"
"    dst_prior[groupIdx % mcu_width * 16 + 8 + localIdx]                  \n"
"      = cr_cache[localIdx + 81];                                         \n"
"  }                                                                      \n"
"  if (localIdx < 64)                                                     \n"
"  {                                                                      \n"
"    dataInCb            = cb_cache[trans8to10];                          \n"
"                                                                         \n"
"    dataInTopCb         = cb_cache[trans8to10 -10];                      \n"
"    dataInBottomCb      = cb_cache[trans8to10 +10];                      \n"
"    dataInRightCb       = cb_cache[trans8to10 + 1];                      \n"
"    dataInLeftCb        = cb_cache[trans8to10 - 1];                      \n"
"    dataInLeftTopCb     = cb_cache[trans8to10 -11];                      \n"
"    dataInRightTopCb    = cb_cache[trans8to10 - 9];                      \n"
"    dataInLeftBottomCb  = cb_cache[trans8to10 + 9];                      \n"
"    dataInRightBottomCb = cb_cache[trans8to10 +11];                      \n"
"  cb_upsample[upsample_offset + 0].x =                                   \n"
"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
"    dataInLeftCb * 3 + dataInLeftTopCb + 8) >> 4;                        \n"
"  cb_upsample[upsample_offset + 0].y =                                   \n"
"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
"    dataInRightCb * 3 + dataInRightTopCb + 7) >> 4;                      \n"
"                                                                         \n"
"  cb_upsample[upsample_offset + 4].x =                                   \n"
"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
"    dataInLeftCb * 3 + dataInLeftBottomCb + 8) >> 4;                     \n"
"  cb_upsample[upsample_offset + 4].y =                                   \n"
"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
"    dataInRightCb * 3 + dataInRightBottomCb + 7) >> 4;                   \n"
"                                                                         \n"
"  }                                                                      \n"
"  else                                                                   \n"
"  {                                                                      \n"
"    dataInCr            = cr_cache[trans8to10_1];                        \n"
"                                                                         \n"
"    dataInTopCr         = cr_cache[trans8to10_1 -10];                    \n"
"    dataInBottomCr      = cr_cache[trans8to10_1 +10];                    \n"
"    dataInRightCr       = cr_cache[trans8to10_1 + 1];                    \n"
"    dataInLeftCr        = cr_cache[trans8to10_1 - 1];                    \n"
"    dataInLeftTopCr     = cr_cache[trans8to10_1 -11];                    \n"
"    dataInRightTopCr    = cr_cache[trans8to10_1 - 9];                    \n"
"    dataInLeftBottomCr  = cr_cache[trans8to10_1 + 9];                    \n"
"    dataInRightBottomCr = cr_cache[trans8to10_1 +11];                    \n"
"                                                                         \n"
"  cr_upsample[upsample_offset1 + 0].x =                                  \n"
"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
"    dataInLeftCr * 3 + dataInLeftTopCr + 8) >> 4;                        \n"
"  cr_upsample[upsample_offset1 + 0].y =                                  \n"
"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
"    dataInRightCr * 3 + dataInRightTopCr + 7) >> 4;                      \n"
"                                                                         \n"
"  cr_upsample[upsample_offset1 + 4].x =                                  \n"
"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
"    dataInLeftCr * 3 + dataInLeftBottomCr + 8) >> 4;                     \n"
"  cr_upsample[upsample_offset1 + 4].y =                                  \n"
"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
"    dataInRightCr * 3 + dataInRightBottomCr + 7) >> 4;                   \n"
"  }                                                                      \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
"                                                                         \n"
"  valueY  = convert_int(dataInY.x);                                      \n"
"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
"                                                                         \n"
"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
"  valueY  = convert_int(dataInY.y);                                      \n"
"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
"                                                                         \n"
"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
"                                                                         \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGB)
"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
#endif
"                                                                         \n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
"  if (localIdx < 128)                                                    \n"
"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
#else
"  if (localIdx < 96)                                                     \n"
"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
#endif
"}                                                                        \n";
